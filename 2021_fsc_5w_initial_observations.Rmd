---
title: "Initial observations on the Myanmar Food Security Cluster 5Ws"
author: "Sean Ng"
date: "29/01/2021"
output: 
  html_document:
    code_download: true
    theme: readable
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: false
    collapsed: false
always_allow_html: true   
---

```{css, echo=FALSE}

#TOC::before {
  content: "";
  display: block;
  height: 70px;
  margin: 2em 20px 40px 20px;
  background-image: url("Myanmar_cluster_blue.png");
  background-size: contain;
  background-position: center center;
  background-repeat: no-repeat;
}
```

```{=html}
<style>
    body .main-container {
        max-width: 1280px;
    }
</style>
```
## Introduction

This report is an overview of the initial observations and analysis performed on the Food Security Cluster 5Ws data for 2021; the issues identified and analysis have been broken into large groups corresponding with the first 4 chapters -- geographical coverage, activities and modalities, partners and beneficiaries. This report ends with a brief section on next steps and an interactive reference table and interactive reference maps.

We have endeavoured to provide actionable information and believe that releasing this report is a necessary part of jump-starting the process of resolving the more pressing concerns identified. Further analysis is merited in several areas; and this will be undertaken once consultations with partners have been completed.

Unless otherwise specified, beneficiary figures in this report are unique beneficiaries, as opposed to beneficiary frequencies.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width=9, message = FALSE, warning=FALSE)
library(tidyverse)
library(readxl)
library(lubridate)
library(stringi)
library(pander)
library(janitor)
library(fuzzyjoin)
library(scales)
library(magrittr)
library(sf)
library(bookdown)
library(data.table)
library(ggsflabel)
library(patchwork)
library(plotly)
library(kableExtra)
library(DT)
library(viridis)

theme_set(theme_light())

# disabling scientific notation
options(scipen = 100)

# pander tables all in one row
panderOptions('table.split.table', Inf)

# pander thousands separator
panderOptions("big.mark", ",")

# replace 
opts <- options(knitr.kable.NA = "")

`%out%` <- Negate(`%in%`)

# function for transposing df
transpose_df <- function(df) {
  t_df <- data.table::transpose(df)
  colnames(t_df) <- rownames(df)
  rownames(t_df) <- colnames(df)
  t_df <- t_df %>%
    tibble::rownames_to_column(.data = .) %>%
    tibble::as_tibble(.)
  return(t_df)
}

# function beneficiary summaries
sum_ben <- function(df, column_var){
  
  column_var <- enquo(column_var)
  
  df %>%
    group_by(!!column_var) %>% # must add bang-bang
    summarise(beneficiaries = sum(beneficiaries)) %>% 
    arrange(desc(beneficiaries))
    
}

# function beneficiary summaries, 2 grouped variables
sum_ben2 <- function(df, column_var1, column_var2){
  
  column_var1 <- enquo(column_var1)
  column_var2 <- enquo(column_var2)
  
  df %>%
    group_by(!!column_var1, !!column_var2) %>% # must add bang-bang
    summarise(beneficiaries = sum(beneficiaries)) %>% 
    arrange(desc(beneficiaries))
    
}

# reading in townships from geoadmins 
townships <- read_excel("FSC 5W 2021 - GEOADMINS_final 19.xlsx",
           sheet = "GEOADMINS") %>% 
  clean_names() %>% 
  select(admin1pcode_4:admin3pcode) %>% 
  rename(admin1_pcode = admin1pcode_4,
         admin3_pcode = admin3pcode,
         state_name   = state_5,
         township_name  = county) %>% 
  remove_empty()

# locations dataset 
locations <- bind_rows(
  
  read_excel("FSC 5W 2021 - GEOADMINS_final 19.xlsx", # payams 
             sheet = "GEOADMINS") %>% 
    clean_names() %>% 
    select(state_name:payam_code) %>% 
    rename(admin1_pcode = state_code_12,
           township_name = county_name, 
           admin3_pcode = county_code,
           location = payam_name) %>%
    remove_empty() %>% 
    mutate(location_type = paste0("payam")),
  
  read_excel("FSC 5W 2021 - GEOADMINS_final 19.xlsx", # camps
             sheet = "GEOADMINS") %>% 
    clean_names() %>% 
    select(county_name1:p_code_camp) %>% 
    rename(township_name = county_name1,
           admin3_pcode = state_code_23,
           location = camps, 
           camp_pcode = p_code_camp) %>% 
    remove_empty() %>% 
    mutate(location_type = paste0("camp")) %>% 
    left_join(townships %>% select(state_name, admin1_pcode, admin3_pcode), 
              by = c("admin3_pcode")) %>% 
    relocate(admin1_pcode) %>% 
    relocate(state_name),
  
  read_excel("FSC 5W 2021 - GEOADMINS_final 19.xlsx", # industrial zones
             sheet = "GEOADMINS") %>% 
    clean_names() %>%
    select(state_28:industrial_zones) %>% 
    rename(state_name = state_28, 
           admin1_pcode = admin1pcode_29,
           location = industrial_zones) %>%
    remove_empty() %>% 
    regex_left_join(townships %>% select(township_name, admin3_pcode),
                    by = c("location" = "township_name")) %>% 
    # replacing the NAs with 0s so the filter doesn't drop them 
    replace_na(list(township_name = 0, admin3_pcode = 0, admin1_pcode = 0)) %>%
    filter(admin3_pcode != "MMR013040") %>% # removing all the matches between Hlaingtharya and Hlaing
    filter(admin3_pcode != "MMR011006") %>% # removing all the matches between Yenangyaung and Ye
    mutate(location_type = paste0("industrial_zone"))
  
)%>%
  mutate(location_code = case_when(location_type == "camp" ~ camp_pcode,
                                   location_type == "payam" ~ payam_code,
                                   location_type == "industrial_zone" ~ NA_character_)) %>%
  mutate(locations_fuzzy = str_replace_all(location, "[[:punct:]]", ""))

# reading in 5ws
fsc <- read_excel(
  "FSC 5W 2021 - GEOADMINS_final 19_Jan to Dec 2021 IM Combined_Draft_28012022.xlsx",
                  sheet = "FSC 5W Activites",
                  skip = 5) %>% 
  janitor::clean_names() %>% 
  select(month_of_implementation:hrp_version) %>% 
  rename_all(~str_replace_all(., "^number_of_", "")) %>%
  rename_all(~str_replace_all(., "^number_", "")) %>% 
  rename(admin4_pcode = admin3_pcode, 
         admin3_pcode = admin2_pcode,
         beneficiaries = reached_beneficiaries,
         households = reached_households,
         beneficiary_type = beneficiaries_type) %>% 
  mutate(industrial_zones = replace(industrial_zones, industrial_zones == "No", NA),
         frequency = replace(frequency, frequency == "N/A", NA)) %>% 
  mutate(location = case_when(camp != "NA" ~ camp,
                              industrial_zones != "NA" ~ industrial_zones,
                              village_ward_town != "NA" ~ village_ward_town)) %>% 
  mutate(location_type = case_when(camp != "NA" ~ "camp",
                              industrial_zones != "NA" ~ "industrial_zone",
                              village_ward_town != "NA" ~ "village_ward_town")) %>%
  mutate(locations_fuzzy = str_replace_all(location, "[[:punct:]]", " ")) %>% 
  mutate(total_value_mmk = value_per_household * households) %>% 
  mutate(date = my(month_of_implementation)) %>% 
  mutate(u_ben = ifelse(unique_beneficiaries == "Yes", beneficiaries, 0)) %>% 
  mutate(state = as.character(fct_recode(state, 
                            "Kachin" = "kachin"))) %>% 
  mutate(mmk_hhd_bin = case_when(value_per_household < 10000 ~ "below_10k",
                             value_per_household >= 10000 & value_per_household <= 20000 ~ "10k_20k",
                             value_per_household > 20000 & value_per_household <= 50000 ~ "20k_50k",
                             value_per_household > 50000 & value_per_household <= 70000 ~ "50k_70k",
                             value_per_household > 70000 & value_per_household < 100000 ~ "70k_100k",
                             value_per_household >= 100000 & value_per_household < 200000 ~ "100k_200k",
                             value_per_household >= 200000 & value_per_household <= 300000 ~ "200k_300k",
                             value_per_household > 300000 ~ "above_300k",
                             TRUE ~ NA_character_),
         mmk_hhd_bin = fct_relevel(mmk_hhd_bin, c("less_than_10k", "10k_20k","20k_50k", "50k_70k", "70k_100k", "100k_200k",
                                          "200k_300k","more_than_300k")),
         frequency = recode(frequency, "monthly" = "Monthly")) %>%
  mutate(usd_hhd_bin = 
           case_when(value_per_household_usd < 10 ~ "<$10",
                     value_per_household_usd >= 10 & value_per_household_usd < 20 ~ ">=$10_<$20",
                     value_per_household_usd >= 20 & value_per_household_usd < 40 ~ ">=$20_<$40",
                     value_per_household_usd >= 40 & value_per_household_usd < 60 ~ ">=$40_<$60",
                     value_per_household_usd >= 60 & value_per_household_usd < 100 ~ ">=$60_<$100",
                     value_per_household_usd >= 100 & value_per_household_usd < 200 ~ ">=$100_<$200",
                     value_per_household_usd >= 200 ~ ">=$200",
                     TRUE ~ NA_character_),
         usd_hhd_bin = fct_relevel(usd_hhd_bin, c("<$10", ">=$10_<$20", ">=$20_<$40", ">=$40_<$60", 
                                                  ">=$60_<$100", ">=$100_<$200", ">=$200"))) %>% 
  mutate(hrp_indicator =
          recode(hrp_indicator,
          "Number of people who received food and/or cash assistance" = 
            "1.Number of people who received food and/or cash assistance",
          "Number of people who received agriculture and other livelihood support, contributing to household food security" =
            "2.Number of people who received agriculture and other livelihood support")) %>% 
  mutate(beneficiary_type = str_trim(beneficiary_type)) %>% 
  mutate(beneficiary_type = as.character(fct_recode(beneficiary_type, 
               "Rakhine stateless" = "Non-displaced stateless people in Rakhine"))) %>% 
  mutate(activity = recode(activity, 
                          "Provide monthly food baskets through in-kind assistance to acutely food insecure population in rural areas" = 
                            "Provide monthly food baskets",
                          "Provide technical training (agriculture, livestock breeding, livelihood)" = "Provide technical training",
                          "Provide support for Income Generating Activities" = "Provide support for income generation",
                          "Provide monthly cash-based transfers to acutely food insecure population in rural areas" =
                            "Provide monthly cash-based transfers",
                          "Cash for Work / Food for Assets activities" = "Cash for Work / Food for Assets",
                          "Provide fishery kits (in-kind / CBT)" = "Provide fishery kits",
                          "Provide crops & vegetables kits (in-kind / CBT)" = "Provide crops & vegetables kits",
                          "Provide livestock kits (in-kind / CBT)" = "Provide livestock kits")) %>% 
  mutate(implementing_partners = recode(implementing_partners, 
                                        "Save the children" = "Save the Children")) %>% 
  mutate(implementing_partner_type = 
           ifelse(implementing_partners %in% c("Kaw Lah Foundation", "Hakha Baptist Association (HBA)", "Arkan Research and Watch",
                                               "Hlaing Development Network", "Mangrove Service Network (MSN)", "Kyal Sin May",
                                               "Swan Saung Shin", "Sein Lei Ayeyar"), "NNGO", implementing_partner_type),
         implementing_partner_type = 
           ifelse(implementing_partners %in% c("Single Touch Point Company Limited (STP)", "Neo Prospect Company Limited"), 
                  "other", implementing_partner_type),
         implementing_partner_type = ifelse(implementing_partners == "Helen Keller International", "INGO", implementing_partner_type))


# ben dataset -- tidy format 5Ws for beneficiaries 
ben <- fsc %>% 
  filter(unique_beneficiaries == "Yes") %>%  
  select(date,
         implementing_partners, implementing_partner_type,
         state, township, village_ward_town, location, location_type, admin1_pcode, admin3_pcode,
         activity, activity_status, hrp_indicator, beneficiary_type, 
         child_male, child_female, adult_male, adult_female, elderly_male, elderly_female) %>% 
  pivot_longer(cols = child_male:elderly_female, 
               names_to = "disaggregation", values_to = "beneficiaries", values_drop_na = TRUE)
 

# reading in pin and targets
pin <- read_excel("PIN calculation Food Security Cluster_Township Breakdown.xlsx",
           sheet = "Food Sec PiN with IDPs", 
           skip = 2) %>% 
  clean_names() %>% 
  select(-c(x17, x18, x19)) %>% 
  slice(1:346) %>% 
  fill(region) %>% 
  rename(state = region,
         idps = id_ps, 
         pop_minus_idps = population_minus_id_ps, 
         pin_2022 = vulnerable_food_insecure_people_id_ps) %>%  
  filter(township != "Total") %>%  
  mutate_at(vars(pop_minus_idps:moderately_severely), ~ as.numeric(.)) %>% 
  left_join(townships, by = c("township" = "township_name")) %>% 
  select(-state) %>%  
  relocate(admin3_pcode) %>% relocate(state = state_name) %>% relocate(admin1_pcode) %>% 
  mutate(pc_vul = pin_2022 / total_pop,
         pin_2022 = round(pin_2022, digits = 0)) %>% 
  left_join(read_excel("FSC PIN and Target _combine HRP and IERP 2021.xlsx") %>%
              clean_names() %>%
              select(admin3_pcode = tsp_pcode, pin_2021 = pin, target_2021 = target), by = "admin3_pcode") %>% 
  left_join(read_excel("fs_targets_2021.xlsx") %>%
              clean_names() %>% 
              select(township = x1,
                     hrp_target_idps_2021 = internally_displaced_persons_12,
                     hrp_target_returnees_2021 = idp_returnees_resettled_locally_integrated_13,
                     hrp_target_stateless_rakhine_2021 = non_displaced_stateless_people_in_rakhine_14,
                     hrp_target_other_vulnerable_2021 = other_vulnerable_crisis_affected_people_15,
                     hrp_target_total = total_16) %>%
              left_join(townships %>%  select(township_name, admin3_pcode), by = c("township" = "township_name")) %>% 
              select(-township),
            by = "admin3_pcode") %>% 
  replace(is.na(.), 0)    


# shapefiles
pcode3_shape <- st_read("./mmr_polbnda_adm3_mimu_250k/mmr_polbnda_adm3_mimu_250k.shp", quiet = TRUE) %>% 
  rename(state = ST, 
         admin1_pcode = ST_PCODE,
         township = TS,
         admin3_pcode = TS_PCODE)

pcode1_shape <- st_read("./mmr_polbnda2_adm1_mimu_250k/mmr_polbnda2_adm1_mimu_250k.shp", quiet = TRUE) %>% 
  rename(state = ST, 
         admin1_pcode = ST_PCODE)

# for relevelling -- this is in order of beneficiaries
sr_ord <- c("Yangon", "Rakhine", "Mandalay", "Ayeyarwady", "Magway", "Kachin", "Shan (North)", "Kayin",
 "Mon", "Sagaing", "Kayah", "Chin", "Shan (South)", "Bago (East)", "Tanintharyi", "Shan (East)")

# for printing the targets of the pin 
target_ben_2021 <- pin %>%  
  select(admin3_pcode, state, township, target_2021) %>% 
  filter(target_2021 > 0) %>% 
  left_join(ben %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries)), by = "admin3_pcode") %>% 
  mutate(pc_reached = beneficiaries / target_2021 * 100) %>%  
  replace(is.na(.), 0) 

```

## 1. Geographical coverage

### 1.1 Comparing beneficiaries reached and 2021 PIN by state and region

A total of `r sum(ben$beneficiaries) %>% format(big.mark = ",")` unique beneficiaries have been reached across the country; this is `r round(sum(ben$beneficiaries) / sum(pin$target_2021) * 100, digits = 2)`% of the targetted `r sum(pin$target_2021) %>% format(big.mark = ",")` persons; however, not all the beneficiaries reached corresponded to areas where there were targets -- this is explored in more detail in the section on townships.

<br>

```{r barplot-state-beneficiaries-pin}
# change the colours -- I really don't like these colours 

pin %>% 
  left_join(ben %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries))) %>% 
  mutate(beneficiaries = ifelse(is.na(beneficiaries), 0, beneficiaries)) %>% 
  group_by(state) %>% 
  summarise(beneficiaries = sum(beneficiaries), 
            target_2021 = sum(target_2021), 
            pin_2021 = sum(pin_2021)) %>% 
  filter(pin_2021 > 0 | beneficiaries > 0) %>% 
  pivot_longer(-state, names_to = "type", values_to = "value") %>% 
  ggplot(aes(x = fct_relevel(state, sr_ord), y = value, fill = fct_relevel(type, c("beneficiaries", "target_2021", "pin_2021")))) +
  geom_col(position = "dodge") +
  scale_fill_brewer(palette = "Accent") +
  theme(axis.text.x = element_text(vjust = 0.4, angle = 70)) +
  theme(legend.title = element_blank()) +
  labs(x = "",
       y = "", 
       title = "Food security beneficiaries and people in need (2021)") +
   scale_y_continuous(breaks = seq(0, 2000000, by = 200000), labels = comma)
```

<br>

### 1.2 Table of beneficiaries and PIN by state and region

```{r table-beneficiaries-pin-state}
# change formulas to look at % of target and show PIN, target and achievement in the table 
pin %>% 
  left_join(ben %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries)), by = "admin3_pcode") %>% 
  mutate(beneficiaries = ifelse(is.na(beneficiaries), 0, beneficiaries)) %>% 
  group_by(state) %>% 
  summarise(beneficiaries = sum(beneficiaries), 
            target = round(sum(target_2021), digits = 0), 
            PIN = round(sum(pin_2021), digits = 0)) %>%
  filter(beneficiaries > 0 | PIN > 0) %>% 
  mutate(`%_of_ben` = round(beneficiaries / sum(beneficiaries) * 100, digits = 2),
         `%_target_reached` = ifelse(is.infinite(beneficiaries / target * 100), NA_real_, beneficiaries / target * 100),
         `%_target_reached` = round(`%_target_reached`, digits = 2),
         `%_of_target` = round(target / sum(target) * 100, digits = 2))  %>% 
  relocate(`%_of_ben`, .after = beneficiaries) %>% 
  relocate(`%_target_reached`, .after = target) %>% 
  relocate(`%_of_target`, .after = target) %>% 
  arrange(desc(beneficiaries)) %>% 
  kbl(caption = "Beneficiaries reached (desc.) and PIN by state/region", format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = c("striped"))
```

<br>

Yangon and Rakhine form both `r round(filter(pin, state %in% c("Yangon", "Rakhine")) %>% {sum(.$target_2021)} / sum(pin$target_2021) * 100)`% of the target and `r round(filter(fsc, state %in% c("Yangon", "Rakhine") & unique_beneficiaries == "Yes") %>% {sum(.$beneficiaries)} / filter(fsc, unique_beneficiaries == "Yes") %>% {sum(.$beneficiaries)} * 100)`% of the beneficiaries reached. Mandalay has has the largest difference between targets and beneficiaries reached. There were five states (Ayeyarwady, Mon, Sagaing, Magway and Tanintharyi) where beneficiaries were reached but were not included as part of the 2021 target or PIN; however, the beneficiaries reached in these areas represent less than 5% of all beneficiaries reached. Additionally, targets have been exceeded in all states except Mandalay, with Kayin having reached 994% of its target of 6,855 persons.

However, moving forward, the PIN for 2022 is much more evenly spread across the country: with reference to the plot below, Yangon, along with Magway and Mandalay have some of the lowest proportions of vulnerable persons in relation to the total state population, meaning that careful beneficiary selection and tight vulnerability in these areas will necessary to avoid excessive inclusion errors.

<br>

```{r barplot-pin-vul-state}
pin %>% 
  group_by(state) %>% 
  filter(state != "Nay Pyi Taw") %>% 
  summarise(pin_2022 = round(sum(pin_2022)),
            total_pop = sum(total_pop)) %>% 
  mutate(`%_of_pop_in_PIN` = round(pin_2022 / total_pop * 100, digits = 2),
         state = reorder(state, -`%_of_pop_in_PIN`))  %>% 
  ggplot(aes(x = state, y = pin_2022, fill = `%_of_pop_in_PIN`)) +
  geom_col() +
  geom_text(aes(label = `%_of_pop_in_PIN`), size = 2.5, vjust = -0.5) +
  theme(axis.text.x = element_text(angle = 70, vjust = 0.5, hjust = 0.6)) +
  labs(x = "",
       y = "Number of people in need", 
       fill = "% of pop \n in PIN",
       title = "2022 PIN and incidence of food insecurity and displacement by state and region",
       subtitle = "The 2022 food security PIN is the number of persons who are food insecure or are IDPs") +
  scale_y_continuous(breaks = seq(0, 2000000, by = 200000), labels = comma) +
  scale_fill_continuous(trans = "reverse")
```

<br>

### 1.3 Township-level distribution of beneficiaries

```{r dataset-ts-target-reached}

ts_target_reached <- pin %>%  
  select(admin3_pcode, state, township, target_2021) %>% 
  filter(target_2021 > 0) %>% 
  left_join(ben %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries)), by = "admin3_pcode") %>% 
  mutate(pc_reached = beneficiaries / target_2021 * 100) %>% 
  replace(is.na(.), 0) %>% arrange(desc(pc_reached))

```

Just as the response is heavily weighted towards Yangon and Rakhine at the state and region level, the same is also true at the township level. These 10 townships below are where 76% of all FSC beneficiaries have been reached, they represent 60% of the 2021 target. In particular, Hlaingtharya has beneficiary figures that are 378% of its target. Additionally, neither Nyaung-U nor Myingyan were targetted as part of the 2021 PIN despite being in the top 10 townships by beneficiaries reached -- `r round(sum(ts_target_reached$beneficiaries) / sum(ben$beneficiaries) * 100, digits = 2)`% of beneficiaries reached corresponded to townships with targets.

```{r table-top-townships-beneficiaries}
# check the paragraph text above if you rerun the report on new data 
ben %>% 
  group_by(admin3_pcode, township, state) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>% 
  left_join(pin %>% select(admin3_pcode, target = target_2021), by = "admin3_pcode") %>%
  mutate(`%_of_ben` = round(beneficiaries / sum(beneficiaries) * 100, digits = 2),
         `%_of_target` = ifelse(is.infinite(target / sum(target, na.rm = TRUE) * 100), NA_real_, target / sum(target, na.rm = TRUE) * 100),
         `%_of_target` = round(`%_of_target`, digits = 2),
         `%reached` = ifelse(is.infinite(beneficiaries / target * 100), NA_real_, beneficiaries / target * 100),
         `%reached` = round(`%reached`, digits = 2), 
         target = round(target)) %>% 
  select(-admin3_pcode) %>% 
  relocate(`%_of_ben`, .after = beneficiaries) %>% 
  relocate(state, .after = township) %>% 
  arrange(desc(beneficiaries)) %>% 
  head(10) %>%
  kable(caption = "Top 10 townships by beneficiaries reached (desc) in 2021", format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = c("striped"))
```

<br>


`r ben %>% select(township) %>% distinct() %>% nrow()` townships have been reached by food security activities in the first three-quarters of 2021. This is `r round(ben %>% select(township) %>% distinct() %>% nrow() / nrow(townships) * 100, digits = 2)`% the 330 townships in the country. It is also important to note that two townships -- Hpapun in Kayin and Kyethi in Shan (South) have been targetted since the initial 2021 HRP, yet have not been reached by any FSC activities; `r filter(ts_target_reached, beneficiaries == 0) %>% nrow` townships, overall, in either the HRP or IERP, have not benefitted from any FSC activities.

Overall, `r round(sum(target_ben_2021$beneficiaries) / sum(target_ben_2021$target_2021) * 100, digits = 2)`% of the targetted population was reached. From the histogram below, we can see that overreach and under-reaching were very common -- townships are commonly clustered at around 0% reached and also at 200% reached or more. Of the `r nrow(filter(ts_target_reached, beneficiaries != 0))` townships reached in 2021; `r nrow(filter(ts_target_reached, pc_reached > 120))` townships reached more than 120% of their target, `r nrow(filter(ts_target_reached, pc_reached > 100 & pc_reached <= 120))` reached between 100% and 119% of their target; `r nrow(filter(ts_target_reached, pc_reached > 80 & pc_reached <= 100))` townships reached between 80% and 100% of their target; and `r nrow(filter(ts_target_reached, pc_reached <= 80 & pc_reached != 0))` townships reached less than 80% of their target.

<br>

```{r histogram-beneficiaries-hrp-target-reached}

ts_target_reached %>% 
  mutate(pc_reached = ifelse(pc_reached > 200, 200, pc_reached)) %>% 
  ggplot(aes(x = pc_reached)) + 
  geom_histogram(bins = 20) + 
  scale_x_continuous(breaks = seq(0, 200, by = 20)) +
  scale_y_continuous(breaks = seq(0, 10, by = 2)) + 
  labs(x = "% of 2021 HRP target reached", 
       y = "Number of townships",
       title = "Distribution of townships by percentage of 2021 HRP target reached", 
       subtitle = "Values above 200% have been lumped together at 200%")
```

<br>

### 1.4 Locations

Partners have responded in a total of `r ben %>% select(location) %>% distinct() %>% nrow()` locations across the country, with the vast majority of locations only having only one partner operating in them; the maximum number of partners in any location is 4. Of the `r fsc %>% nrow()` rows reported in the 5Ws, only `r sum(is.na(fsc$location))` did not report a specific location.

Locations are classified into three groups -- camps, industrial zones and villages/towns/wards:

```{r table-locations}

ben %>% 
  filter(!is.na(location)) %>% 
  group_by(location_type) %>% 
  summarise(locations = n_distinct(location),
            townships = n_distinct(township),
            beneficiaries = sum(beneficiaries)) %>% 
  mutate(pc_of_ben = round(beneficiaries / sum(beneficiaries) * 100, digits = 2), 
         avg_ben_per_loc = round(beneficiaries / locations, digits = 0)) %>% 
  arrange(desc(beneficiaries)) %>%
  kable(caption = "Summary of location types", format.args = list(big.mark = ",")) %>% 
  kable_classic_2()
  # pander(caption = "Summary of location types")
```

<br>

The vast majority of locations are served by only one partner. Below are a series of histograms showing the variation in the number of beneficiaries by location, split by number of partners in each location. Locations with one partner present have a large peak around 100 beneficiaries per locations; and a slight majority of locations with two partners have more than 1,000 beneficiaries.

```{r histogram-locations-by-partner}

ben %>% 
  filter(!is.na(location)) %>% 
  group_by(location, township) %>%  
  summarise(beneficiaries = sum(beneficiaries), 
            partners = n_distinct(implementing_partners), .groups = "drop") %>% 
  arrange(desc(partners)) %>% 
  ggplot(aes(x = beneficiaries)) +
  geom_histogram(binwidth = 0.1) +
  scale_x_log10() +
  facet_wrap(~ partners) +
  labs(y = "number of locations",
       x = "beneficiaries per location", 
       title = "Histograms of beneficiaries by location",
       subtitle = "Faceted by number of partners per location")

```

<br>

The more partners operating in a given location, the higher the average number of beneficiaries; however, it should be noted that these multi-partner locations are comparatively rare. The location with four partners is Nam Hlaing in Bhamo, Kachin.

```{r table-locations-partners}
ben %>% 
  filter(!is.na(location)) %>% 
  group_by(location, township) %>%  
  summarise(beneficiaries = sum(beneficiaries), 
            number_of_partners = n_distinct(implementing_partners), .groups = "drop") %>% 
  group_by(number_of_partners) %>% 
  summarise(locations = sum(n_distinct(location)),
            avg_beneficiaries = median(beneficiaries), .groups = "drop") %>%
  mutate(number_of_partners = recode(number_of_partners, `1` = "one",
                           `2` = "two",
                           `3` = "three",
                           `4` = "four")) %>% 
  kable(caption = "Average beneficiaries by locations with one, two, three and four partners", format.args = list(big.mark = ",")) %>% 
  kable_classic_2(full_width = FALSE, position = "left")
 # pander(caption = "Average beneficiaries by locations with one, two, three and four partners")

```

<br><br>

## 2. Activities and modalities

### 2.1 Progress by activity

```{r line-plot-facet-activity}
ben %>% 
  group_by(activity) %>% 
  arrange(date) %>% 
  mutate(cum_ben = cumsum(beneficiaries)) %>% 
  ggplot(aes(x = date, y = cum_ben, colour = activity)) +
  geom_line(size = 1) +
  scale_x_date(date_breaks = "1 month", date_labels = "%b") +
  scale_y_continuous(labels = comma) +
  facet_wrap(~ activity, scales = "free_y") +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 5)) + # see if this works when you knit, then do it for the other plots 
  labs(x = "", 
       y = "cumulative beneficiaries", 
       title = "Monthly progress by activity, 2021") + 
  theme(plot.title = element_text(size = 12))

```

Partners reported their achievements across the eight 5W activities. We see that the majority of the caseload for monthly cash-based transfers was established prior to 2021 (with the number of beneficiaries only increasing very incrementally across the course of the year) -- this aligns with our understanding that many of the projects contributing to this activity were multi-year in nature and had been ongoing prior to the HRP; this pattern is also apparent in the provision of technical training.

One of the difficulties of interpreting these data is that it is not always apparent where the patterns observed are reflective or changes in the field (such as changes in access, funding or staffing) or if they are instead due to partners' reporting behaviours. We note, for instance, a large jump in the number of beneficiaries for fishery kits and food baskets around July 2021 -- this was due to the newly-approved addendum to the HRP. However, some of the other changes are less clear and will require careful exploration with partners.

<br>

### 2.2 Delivery modalilties

Cash and in-kind distributions were each the main delivery modality in three activities, with the provision of services and support being predominant in two. The in-kind modality has the highest reach, given the especially large beneficiary numbers originating from the provision of monthly food baskets. We also note several misclassifications -- small portions of monthly cash transfers have been coded as "in-kind" and there are in-kind food baskets coded as "cash" and "hybrid". It might also be worth more clearly delineating between "support for income-generating activities" and the "provision of technical training" as service delivery and support are heavily present in both.

<br>

```{r barplot-facet-activity-modality}
fsc %>% 
  filter(!is.na(delivery_modality)) %>% 
  group_by(delivery_modality, activity) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>%
  mutate(delivery_modality = recode(delivery_modality, 
                                    "Hybrid (In-kind & Cash)" = "Hybrid",
                                    "Service delivery/support" = "Services/support")) %>% 
  ggplot(aes(x = delivery_modality, y = beneficiaries, fill = activity)) +
  geom_col() +
  scale_y_continuous(labels = comma) +
  labs(x = "",
       title = "Delivery modality by activity, 2021",
       subtitle = "Figures are in beneficiary frequencies") + 
  theme(plot.title = element_text(size = 12),
        legend.position = "none", 
        axis.text.x = element_text(angle = 40, hjust = 0.5, vjust = 0.5)) +
  facet_wrap(~ activity, scales = "free_y")

```

<br>

`r round(filter(fsc, delivery_modality == "In-kind") %>% {sum(.$beneficiaries)} / sum(fsc$beneficiaries) * 100)`% of beneficiary frequencies received support through the in-kind delivery modality; we use beneficiary frequencies here as there were several instances of modalities changing partway through an intervention: for reference, `r round(filter(fsc, delivery_modality == "In-kind") %>% {sum(.$u_ben, na.rm = TRUE)} / sum(fsc$u_ben, na.rm = TRUE) * 100)`% of beneficiaries were reached initially with in-kind interventions, meaning that there was a tendency to diversify away from in-kind support over 2021. `r round(filter(fsc, delivery_modality == "Cash") %>% {sum(.$beneficiaries)} / sum(fsc$beneficiaries) * 100)`% of beneficiary frequencies were reached by cash transfers.

<br>

```{r table-modality-frequency}

# changed to beneficiary frequencies instead of unique beneficiaries 
fsc %>% 
  filter(!is.na(delivery_modality)) %>% 
  group_by(delivery_modality, frequency) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>% 
  filter(beneficiaries > 0) %>% 
  pivot_wider(names_from = frequency, values_from = beneficiaries) %>% 
  adorn_totals("col", na.rm = TRUE) %>% 
  mutate(`%Total` = round(Total / sum(Total) * 100, digits = 2)) %>% 
  arrange(desc(Total)) %>% 
  adorn_totals("row", na.rm = TRUE) %>% 
  kable(caption = "Beneficiary frequencies by delivery modalities and frequency of distribution", format.args = list(big.mark = ",")) %>% 
  kable_classic_2("striped") 
  # pander(caption = "Beneficiary frequencies by delivery modalities and frequency of distribution")

```

<br>

Regarding the table above, there is a strong argument to remove the option "other" from the 5W column `frequency` (referring to frequency of transfer/delivery) -- what exactly it connotes is unclear, as partners might elect this option for activities that occur both more and less frequently than every month; there is also the possibility that partners are just electing "other" instead of leaving the column blank. It is possible to backfill some of the "other" values from the `beneficiary_recurrency` column. This will be explored further in the chapter on beneficiaries. 

There is also justification to drop the "First" category as it does not really have much relation to the "Monthly" category, i.e. an increase in beneficiaries reported as "First" do not correspond to an increase in "Monthly" beneficiaries in the following months, meaning that these beneficiaries should fall under the "One-off" category. 

A key piece of missing information not currently captured by the 5W template is the duration of these activities -- the number of months a monthly food basket is provided can only be calculated somewhat reliably with considerable effort. The table below shows the average duration (in months) of the various activities in the `frequency` category "Monthly":

<br>

```{r table-avg-duration-activities}
fsc %>%  
  filter(frequency == "Monthly") %>% 
  group_by(activity, township, location) %>%
  summarise(recurrences = n_distinct(date), .groups = "drop") %>%
  group_by(activity) %>% 
  summarise(avg_duration_months = round(mean(recurrences), digits = 2)) %>% 
  arrange(desc(avg_duration_months)) %>% 
  kable(caption = "Average duration (in months) of monthly activities") %>% 
  kable_classic_2(full_width = FALSE, position = "left")
  # pander(caption = "Average duration (in months) of monthly activities")
  
```

<br>

### 2.3 Monetary values of intervention packages per household

<br>

```{r plot-usd-hhd-bin}
fsc %>% 
  filter(unique_beneficiaries == "Yes" & !is.na(usd_hhd_bin)) %>%
  filter(delivery_modality %in% c("Cash", "Hybrid (In-kind & Cash)", "Voucher")) %>%
  group_by(usd_hhd_bin) %>%  
  summarise(households = sum(households)) %>%
  mutate(`%_of_households` = round(households / sum(households)* 100, digits = 2)) %>% 
  ggplot(aes(x = usd_hhd_bin, y = households, fill = usd_hhd_bin)) +
  geom_col() +
  geom_text(aes(label = `%_of_households`), vjust = -0.5, size = 3) +
  scale_fill_brewer(palette = "Greens") +
  scale_y_continuous(labels = comma, breaks = seq(0, 30000, by = 5000)) +
  theme(legend.position = "none") +
  labs(x = "USD value of cash transfer per household",
       y = "Number of households",
       title = "Number and percentage of households by value of cash transfer per household")
```

<br>

The most common transfer values -- in terms of beneficiaries reached -- are between USD 10 and USD 20, though it should be noted that a not insignificant number of households (about 7%) were reached by cash transfer interventions valued at USD 100 per household or more. Please note that these monetary values were calculated only from rows with unique beneficiaries and that we are not using the cumulative sums per household.

<br>

```{r table-usd-hhd-bin-frequency}
cash_delivery_mechanism <- fsc %>%  
  filter(!is.na(usd_hhd_bin) & unique_beneficiaries == "Yes" & !is.na(cash_delivery_mechanism) ) %>% 
  filter(delivery_modality %in% c("Cash", "Hybrid (In-kind & Cash)", "Voucher")) %>% 
  mutate(households = round(households)) %>% 
  count(usd_hhd_bin,cash_delivery_mechanism, wt = households) %>%
  pivot_wider(names_from = usd_hhd_bin, values_from = n) %>% 
  adorn_totals("col", na.rm = TRUE) %>% 
  rename(total_hhd = Total) %>% 
  mutate(pc_of_hhd = round(total_hhd / sum(total_hhd) * 100, digits = 2)) %>% 
  arrange(desc(total_hhd)) 

cash_delivery_mechanism %>% 
  kable(caption = "Cash transfer, hybrid and voucher values per household by cash delivery mechanism (USD)", 
        format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = "striped")


```

<br>

by far the most common cash delivery mechanism was direct cash payments -- `r filter(cash_delivery_mechanism, cash_delivery_mechanism == "Direct cash payment") %>%  pull(pc_of_hhd)`% of beneficiaries were reached through this mechanism. Transfers made through MOney transfer agents had the highest average transfer amount. 


Next, let us take a look at household package values by activity type:

```{r}
fsc %>% 
  filter(unique_beneficiaries == "Yes") %>% 
  group_by(activity) %>% 
  summarise(households = round(sum(households, na.rm = TRUE)),
            total_value_usd = round(sum(total_value_usd, na.rm = TRUE))) %>% 
  mutate(avg_transfer_value = round(total_value_usd / households, digits = 2)) %>% 
  arrange(desc(avg_transfer_value)) %>%  
  kable(caption = "Average value (USD) of household package values per activity", 
        format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = "striped")
  
```

<br>

Overall, the highest average cash transfers were from the provision of livestock kits and the lowest averages from fishery kits (after discounting food baskets, where less than 1% of activities reported the package value). It is also unclear if fishery kits and technical training tended to have particularly small cash components or if there were data entry errors. But the average package values are only part of the picture and significant variation in transfer values exists within each activity:

<br>

```{r barplot-facet-usd-hhd-bin-activity}
fsc %>% 
  filter(!is.na(usd_hhd_bin) & unique_beneficiaries == "Yes") %>% 
  filter(delivery_modality %in% c("Cash", "Hybrid (In-kind & Cash)", "Voucher")) %>%
  group_by(activity, usd_hhd_bin) %>% 
  summarise(households = sum(households)) %>% 
  ggplot(aes(x = usd_hhd_bin, y = households, fill = activity)) +
  geom_col() +
  scale_y_continuous(labels = comma) +
  labs(x = "") +
  labs(title = "Variation in the  per household values of intervention packages in USD", 
       subtitle = "Faceted by activity; contains only data from activities using cash, hybrid or voucher modalities") +
  theme(legend.position = "none", 
        axis.text.x = element_text(angle = 90), 
        plot.title = element_text(size = 12)) +
  facet_wrap(~ activity, scales = "free_y")

```

<br>
 
It would be fruitful to explore the provision of monthly cash-based transfers in more detail -- this activity has a very clear peak at `>=$10_<$20`. A closer look reveals that this is almost entirely due to the `r fsc %>% filter(value_per_household_usd == 10.5 & unique_beneficiaries == "Yes") %>% {sum(.$households)} %>% round() %>% format(big.mark = ",")` beneficiaries who received monthly transfers of USD 10.50/month (or MMK 15,000) per household. It is unclear whether this is a data entry error -- but what we do know is that the households that received this type of transfer were not smaller than average; it might also be possible that this activity had been conceived as one singular transfer that had been split across several months.

This should be followed up with the 7 partners who provided this transfer value to beneficiary households; they are: WFP, Plan International, Save the Children, Myanmar Heart Development Organisation, People for People, World Vision Myanmar and People in Need.

This amount falls far below the minimum expenditure basket for food identified by the Cash Working Group, which established a floor of MMK 190,555 per household per month. Below is a table which summarises the percentage of the minimum expenditure basket for food which is covered by the different bins we have established for the cash-transfer values:

```{r table-meb-usd-hhd-bin}

fsc %>% 
  filter(unique_beneficiaries == "Yes" & activity == "Provide monthly cash-based transfers") %>% 
  filter(!is.na(value_per_household)) %>% 
  mutate(pc_meb = value_per_household / 190555) %>% 
  group_by(usd_hhd_bin) %>% 
  summarise(avg_pc_of_meb = round(mean(pc_meb) * 100, digits = 2),
            avg_usd_month = round(mean(value_per_household_usd, na.rm = TRUE), digits = 2),
            households = round(sum(households))) %>% 
  mutate(pc_of_hhd = round(households / sum(households) * 100, digits = 2)) %>% 
  kable(caption = "Monthly cash-based transfer by percentage of MEB received", format.args = list(big.mark = ",")) %>% 
  kable_classic_2("striped") 

```

<br>

Around 10.5% of beneficiaries of monthly cash-based transfers have received more than 50% of the value of the minimum expenditure basket for food. Notably, 13% of beneficiary households have received less than USD 10 per household per month. This underscores the importance of standardisation: beneficiaries have already received very different package amounts and there is a pressing need to collect information on whether cash transfers (and food baskets) have been designed to be full rations, half rations or are instead intended to be supplementary activities. This is key from a coordination standpoint as we cannot consider the food security needs of those who have only received supplementary transfers to have been covered.


<br><br>

## 3. Partners

Of the implementing partners of the Food Security Cluster, a total of `r fsc %>% select(implementing_partners) %>% distinct() %>% nrow()` of them classified themselves as implementing partners within the 5Ws. They are fairly evenly split themselves between HRP indicators, with `r fsc %>% filter(str_detect(hrp_indicator, "1.")) %>% select(implementing_partners) %>% distinct() %>% nrow()` contributing towards food and cash assistance and `r fsc %>% filter(str_detect(hrp_indicator, "2.")) %>% select(implementing_partners) %>% distinct() %>% nrow()` contributing towards agriculture and other livelihood support. `r ben %>% sum_ben(implementing_partners) %>% filter(beneficiaries < 10000) %>% nrow()` partners have reached less than 10,000 unique beneficiaries and the median unique beneficiaries reached by partners is `r ben %>% sum_ben(implementing_partners) %>% {median(.$beneficiaries)} %>% format(big.mark = ",")`. Below are the top 10 partners by HRP indicator. As a side note, Zigway should be considered as a vendor/supplier of WFP, and not the implementing partner -- some follow up with WFP will be necessary to rectify this.

```{r table-top-partners-by-hrp-indicator}

# reminder to redo the numbers when you rerun this with fresh data 

cbind(
  
  fsc %>% 
    filter(hrp_indicator == "1.Number of people who received food and/or cash assistance" &
             beneficiaries_recurrency %in% c("First", "One-off")) %>% 
    group_by(implementing_partners) %>% 
    summarise(beneficiaries = sum(beneficiaries)) %>% 
    arrange(desc(beneficiaries)) %>% 
    rename(`1. Number of people who received food and/or cash assistance` = beneficiaries,
           `Partners HRP indicator1` = implementing_partners) %>% 
    head(10),
  
  fsc %>% 
    filter(hrp_indicator == "2.Number of people who received agriculture and other livelihood support" &
             beneficiaries_recurrency %in% c("First", "One-off")) %>% 
    group_by(implementing_partners) %>% 
    summarise(beneficiaries = sum(beneficiaries)) %>% 
    arrange(desc(beneficiaries)) %>% 
    rename(`2. Number of people who received agriculture and other livelihood support` = beneficiaries,
           `Partners HRP indicator2` = implementing_partners) %>% 
    head(10)
  
) %>% 
  add_column(` ` = " ") %>% 
  relocate(` `, .after = `1. Number of people who received food and/or cash assistance`) %>% 
  
  kable(caption = "Top 10 partners by beneficiaries reached, by HRP indicator", format.args = list(big.mark = ",")) %>% 
  kable_classic_2("striped")
# pander(caption = "Top 10 partners by beneficiaries reached, by HRP indicator")

```

<br>

### 3.1 Distribution of partners by beneficiaries and geographic reach

Whilst there is quite a bit of variation in the number of beneficiaries reached, we can see that partners' geographic footprints are -- on the whole -- quite limited. Only `r ben %>% group_by(implementing_partners) %>% summarise(townships = n_distinct(admin3_pcode)) %>% filter(townships > 10) %>% nrow()` partners have a presence in more than 10 townships, with only `r ben %>% group_by(implementing_partners) %>% summarise(townships = n_distinct(admin3_pcode)) %>% filter(townships > 5) %>% nrow()` being present in more than 5 townships. 78% of our partners (clustered along the bottom of the chart) are present in 5 or less townships. This distribution of partners is an impediment to a countrywide response and it is imperative to understand how best to incentivise partners to expand their footprints.

<br>

```{r plotly-scatter-partners-reach}
# reminder to recalculate the 79% above if you rerun the data 
partner_scatter <- ben %>% 
  group_by(implementing_partners) %>% 
  summarise(states = n_distinct(admin1_pcode),
            townships = n_distinct(admin3_pcode),
            beneficiaries = sum(beneficiaries)) %>% 
  arrange(desc(states)) %>% 
  ggplot(aes(x = beneficiaries, y = townships, text = implementing_partners)) +  
  geom_point(aes(size = beneficiaries)) +
  scale_x_continuous(trans = "log", labels = comma, breaks = c(0, 100, 1000, 10000, 100000, 300000)) +
  scale_y_continuous(breaks = seq(0, 30, 5)) +
  labs(x = "Number of beneficiaries",
       y = "Number of townships",
       title = "Plot of beneficiaries and townships reached, by implementing partner") 
# for some reason, removing this messes with the alignment of the plot

ggplotly(partner_scatter) %>%
  config(displayModeBar = FALSE) %>% 
  layout(title = list(text = paste0("Plot of beneficiaries and townships reached, by implementing partner",
                                    "<br>", 
                                    "<sup>",
                                    "mouse over for details",
                                    "</sup>")))

```

<br>

### 3.2 Maps of number of partners and 2022 people in need by state/region

```{r has-partner-dataset}
has_partner <- pin %>% select(state, admin3_pcode, township, pin_2022) %>% 
  left_join(ben %>%  
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries), 
                        partners = n_distinct(implementing_partners)), by = "admin3_pcode") %>% 
  replace(is.na(.), 0) %>% 
  mutate(has_partner = ifelse(partners == 0, FALSE, TRUE)) %>% 
  group_by(has_partner) %>% 
  summarise(pin_2022 = sum(pin_2022),
            townships = n()) %>% 
  adorn_percentages("col") %>% 
  mutate(pin_2022 = round(pin_2022 * 100, digits = 2),
         townships = round(townships * 100, digits = 2))


```

Food Security Cluster partners are not well-positioned to meet the needs of the 2022 population in need. Partners are largely concentrated in Kachin, Rakhine and Yangon, with only one partner present in Shan (East) and two in Tanintharyi.

Overall, `r round(has_partner %>% filter(has_partner == FALSE) %>% pull(townships))`% of townships, containing `r round(has_partner %>% filter(has_partner == FALSE) %>% pull(pin_2022))`% of the 2022 PIN, do not have any partners present. This lack of nationwide coverage will be one of the most important constraints that the FSC will face in meeting the 2022 needs of vulnerable, food insecure persons and IDPs -- and resolving this will necessitate both increasing partner coverage and finding new partners for the cluster.

```{r map-partners-pin-township, fig.height=10}
# play with geom_line for the interactive reference map -- maybe you can get the outlines to be in different colours

ben %>% 
  group_by(admin3_pcode) %>% 
  summarise(partners = n_distinct(implementing_partners)) %>% 
  right_join(pcode3_shape, by = "admin3_pcode") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = partners), size = 0.1) +
  scale_fill_gradient(trans = "reverse", breaks = c(1, 3, 5, 7, 9,11)) +
  theme_void() + 
  theme(legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        legend.key.size = unit(0.7, 'cm')) +
  labs(title = "Map of number of partners by township") +

pin %>% 
  group_by(admin3_pcode) %>% 
  summarise(PIN = sum(pin_2022)) %>% 
  mutate(PIN = round(PIN, digits = 0), 
         PIN = recode(PIN, 
                      '0' = NA_real_)) %>%
  right_join(pcode3_shape, by = "admin3_pcode") %>% 
  st_as_sf() %>% 
  ggplot() +
  geom_sf(aes(fill = PIN), size = 0.1) +
  scale_fill_gradient(trans = "reverse", breaks = c(10000, 50000, 100000, 150000, 180000)) +
  theme_void() +
  theme(legend.text = element_text(size = 10),
        legend.title = element_text(size = 10),
        legend.key.size = unit(0.7, 'cm')) +
  labs(title = "Map of 2022 PIN by township")

```

### 3.3 Reporting organisations

There are `r fsc %>% distinct(reporting_organization, implementing_partners) %>% nrow()` combinations between reporting organisations and implementing partners, `r fsc %>% distinct(reporting_organization, implementing_partners) %>% filter(reporting_organization == implementing_partners) %>% nrow()` of which are instances where the reporting organisation and the implementing partner are the same organisation; once these are filtered out, all the remaining implementing partners correspond to just `r fsc %>% filter(reporting_organization != implementing_partners) %>% distinct(reporting_organization) %>% nrow()` reporting organisations:

```{r table-reporting-organisation}
fsc %>% 
  filter(reporting_organization != implementing_partners) %>% 
  group_by(reporting_organization) %>% 
  summarise(implementing_partners = n_distinct(implementing_partners)) %>% 
  arrange(desc(implementing_partners)) %>% 
  kable(caption = "Number of implementing partners by reporting organisation") %>% 
  kable_classic_2("striped", full_width = FALSE, position = "left")

```

<br>

Regarding questions of membership, it would be safe to say that all partners who reported in the 5Ws -- be they reporting organisations or implementing partners -- in addition to strategic partners and partners who aid in analysis who are not represented in the 5Ws, are FSC partners. However, for this report, we have used `implementing_partners` for most of the analysis as, by their nature, reporting organisations do not have a field presence. As a side note, FAO has not classified itself as an implementing partner, having reported no activities that were directly implemented by them.

<br>

### 3.4 Types of implementing partners

```{r table-implementing-partner-type, warning=FALSE}
fsc %>% 
  group_by(implementing_partner_type, implementing_partners) %>%  
  summarise(beneficiaries = sum(beneficiaries), 
            townships = n_distinct(admin3_pcode),
            states = n_distinct(admin1_pcode), .groups = "drop") %>% 
  group_by(implementing_partner_type) %>% 
  summarise(avg_beneficiaries = round(mean(beneficiaries)),
            avg_townships = round(mean(townships), digits = 2), 
            avg_states = round(mean(states), digits = 2), 
            .groups = "drop") %>%  
  mutate(implementing_partner_type = fct_relevel(implementing_partner_type, levels = c("INGO", "NNGO", "UN", "other"))) %>% 
  kable(caption = "Average reach by implementing partner type", format.args = list(big.mark = ",")) %>% 
  kable_classic_2()
  # pander(caption = "Average reach by implementing partner type")

```

<br>

INGOs, on average, reached more beneficiaries across more townships than NNGOs, perhaps due to the generally tighter focus of several community-based organisations. There is only one agency in the "UN" category -- WFP; the "other" category refers to two private limited companies which also implemented food security activities.

<br>

### 3.5 Donors

`r round(sum((!is.na(fsc$donor))) / nrow(fsc) * 100, digits = 0)`% of the rows had the `donor` column filled; however, this only represents activities reaching 23% of all beneficiaries. Below is a table of the 10 donors (after organisations using their own resources) whose funding  has reached the most beneficiaries and the number of townships their funding has been used in:

```{r donor-table}
fsc %>% 
  filter(unique_beneficiaries == "Yes") %>% 
  group_by(donor) %>% 
  summarise(beneficiaries = sum(beneficiaries),
            townships = n_distinct(admin3_pcode)) %>% 
  mutate(pc_of_ben = round(beneficiaries / sum(beneficiaries) * 100, digits = 2)) %>% 
  relocate(pc_of_ben, .after = beneficiaries) %>% 
  filter(!is.na(donor)) %>% 
  arrange(desc(beneficiaries)) %>% 
  head(11) %>% 
  kable(caption = "Top 10 donors by number of beneficairies reached with their funding", format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = c("striped"))
```

<br>

Additionally, we also observe a number of errors, including cases where multiple donors have been combined into one row as well as numerous instances where UNDP, WFP, FAO and UN WOMEN were classified as donors as opposed to reporting organisations. Helvetas should also probably have reported under "organisations using their own funds". 

<br><br>

## 4. Beneficiaries

### 4.1 Beneficiary disaggregations

Currently, in the 5Ws, the vast majority of beneficiary diasaggregations have been backfilled from census data and do not, consequently, provide an accurate picture of the population that have been reached by Food Security interventions. It is not possible to determine how far reality diverges from what has been reported so far -- meaning that we also cannot determine if there has been any bias in beneficiary selection and targetting. It is imperative to begin collecting disaggregated beneficiary data from partners.

It is entirely possible that partners are collecting this data -- disaggregated beneficiary data is one of the most common data required for internal and external reporting -- and that it is merely necessary to work with partners to wrangle their data into the 5W format. However, the capacities of partners to disaggregate beneficiary data should be investigated by the cluster and is an important issue that should be brought up in te next plenary session.

<br>

### 4.2 Types of beneficiaries

```{r beneficiary-type-dataset}
ben_type <- fsc %>% 
  filter(!is.na(beneficiary_type) & unique_beneficiaries == "Yes") %>% 
  group_by(beneficiary_type) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>%
  adorn_percentages(denominator = "col", na.rm = TRUE) %>% 
  mutate(beneficiaries = round(beneficiaries * 100, digits = 2))
```

The states and regions in which we are working the most with IDPs are Bago (East), Kachin, Chin, Shan (North) and Kayah. Overall, `r ben_type %>% filter(beneficiary_type == "Host/local Community") %>% pull(beneficiaries)`% of beneficiaries are from the host/local community, `r ben_type %>% filter(beneficiary_type == "Rakhine stateless") %>% pull(beneficiaries)`% are stateless persons from Rakhine and `r ben_type %>% filter(beneficiary_type == "Internally Displaced") %>% pull(beneficiaries)`% are IDPs. Returnees are the rarest type of beneficiary reached, forming only `r ben_type %>% filter(beneficiary_type == "Returnees") %>% pull(beneficiaries)`% of all beneficiaries reached. Each row in the table below shows the percentage of each beneficiary type within each state/region.

```{r table-beneficiary-types-state}
fsc %>% 
  filter(!is.na(beneficiary_type) & unique_beneficiaries == "Yes") %>% 
  group_by(state, beneficiary_type) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>%  
  pivot_wider(names_from = beneficiary_type, values_from = beneficiaries) %>% 
  adorn_totals(where = "row", na.rm = TRUE) %>% 
  adorn_percentages(denominator = "row", na.rm = TRUE) %>% 
  mutate(across(-state, ~ round(. * 100, digits = 2))) %>% 
  left_join(fsc %>% 
              filter(!is.na(beneficiary_type) & unique_beneficiaries == "Yes") %>%
              sum_ben(state), by = "state") %>% 
  kable(caption = "Percentage breakdown of beneficiary types by state/region", format.args = list(big.mark = ",")) %>% 
  kable_classic_2(lightable_options = "striped")

```

<br>

Compared to only the 2021 HRP targets (as the IERP does not have breakdowns of the target by beneficiary type), we can see that whilst targets have been mostly exceeded, neither the targets for returnees/resettled in Kachin or Shan (North) nor targets for IDPs in Rakhine or Kayin have been met. Interestingly, for Rakhine, the targets for the host/local population have been greatly exceeded, perhaps indicating that once targets were met, all further allocations were targetted at the host/local communities. In Bago (East), Chin, Kayin and particularly Shan (North), the targets for IDPs have been greatly exceeded, in comparison to the 2021 HRP targets:

```{r table-beneficiary-type-reached-hrp-target}
# reminder to check the text in the paragraph above when you rerun the report with data
pin %>%
  filter(hrp_target_total > 0) %>% 
  select(state, admin3_pcode, hrp_target_idps_2021, hrp_target_returnees_2021, hrp_target_stateless_rakhine_2021, 
                     hrp_target_other_vulnerable_2021, hrp_target_total) %>% 
  left_join(fsc %>% 
            filter(!is.na(beneficiary_type) & unique_beneficiaries == "Yes") %>% 
  group_by(admin3_pcode, beneficiary_type) %>% 
  summarise(beneficiaries = sum(beneficiaries), .groups = "drop") %>%
  pivot_wider(names_from = beneficiary_type, values_from = beneficiaries) %>% 
  mutate(total_beneficiaries = rowSums(across(where(is.numeric)), na.rm = TRUE)), by = "admin3_pcode") %>% 
  clean_names() %>%
  replace(is.na(.), 0) %>% 
  group_by(state) %>% 
  summarise_at(vars(hrp_target_idps_2021:total_beneficiaries), ~sum(.)) %>% 
  mutate(host_local_pc = host_local_community / hrp_target_other_vulnerable_2021 * 100, 
         idp_pc = internally_displaced / hrp_target_idps_2021 * 100,
         returnees_pc = returnees / hrp_target_returnees_2021 * 100,
         rakhine_stateless_pc = rakhine_stateless / hrp_target_stateless_rakhine_2021 * 100,
         total_pc = total_beneficiaries / hrp_target_total * 100) %>% 
  select(state, host_local_pc, idp_pc, returnees_pc, rakhine_stateless_pc, total_pc) %>%
  mutate_at(vars(host_local_pc, idp_pc, returnees_pc, rakhine_stateless_pc, total_pc), ~ replace(., is.nan(.), NA)) %>%
  mutate_at(vars(host_local_pc, idp_pc, returnees_pc, rakhine_stateless_pc, total_pc), ~ replace(., is.infinite(.), NA)) %>%
  mutate_at(vars(host_local_pc, idp_pc, returnees_pc, rakhine_stateless_pc, total_pc), ~ round(., digits = 2)) %>%
  rename(`host_local%` = host_local_pc,
         `idp%` = idp_pc,
         `returnees%` = returnees_pc,
         `rakhine_stateless%` = rakhine_stateless_pc,
         `total%` = total_pc) %>% 
  kable(caption = "Percentage of 2021 HRP target reached by beneficiary type") %>% 
  kable_classic_2("striped")
  # pander(caption = "Percentage of 2021 HRP target reached by beneficiary type")

  
```

<br>

Stateless persons from Rakhine have the largest average household sizes, with returnees having the largest variations in household size. With reference to the plot below, the thick bar in the middle of each box shows the average household size for each beneficiary type -- this value is also shown in the text label below the line. The lower and upper borders of each box indicate the values for the 25th and 75th percentiles respectively. For instance, we can see that households at the 25th percentile of households in host/local communities have only four members and households that have around 5 members have more members than 75% of all the households in that group. Outliers are marked by dots. We note a lot of potential data entry errors where less than one person per household was reported.

<br>

```{r boxplot-household-size-beneficiary-type}

# this is for the labels for the boxplot
hhd_labs <- fsc %>%  
  filter(beneficiary_type != "NA") %>% 
  group_by(beneficiary_type) %>%
  summarise(beneficiaries = sum(beneficiaries, na.rm = TRUE),
            households = sum(households, na.rm = TRUE)) %>% 
  mutate(avg_hhd_size = round(beneficiaries / households, digits = 2))  
 

# for some reason, the mutate fct_reorder is not working
# you figured this out but have neglected to write the answer here 
 
fsc %>% 
  filter(beneficiary_type != "NA") %>% 
  group_by(beneficiary_type) %>% 
  mutate(avg_hhd_size = beneficiaries / households, na.rm = TRUE) %>% 
  ggplot(aes(x = fct_reorder(beneficiary_type, avg_hhd_size), y = avg_hhd_size)) + 
  geom_boxplot() +
  geom_text(data = hhd_labs, aes(label = avg_hhd_size), size = 2.5, vjust = -1) +
  scale_y_continuous(breaks = seq(0, 14, 2), limits = c(0,14)) +
  labs(x = "", 
       y = "Average household size",
       title = "Average household size by beneficiary types")

```

<br>

### 4.3 Gaps in monthly programming

```{r table-gaps-months}
# I feel like this is the most inefficient way to do this; still works, though 
# you're going to need to rewrite this when you have Q4 data 
gap_months <- fsc %>% 
  filter(frequency == "Monthly" & beneficiaries > 0) %>% 
  group_by(date, implementing_partners, activity, state, township, location) %>% 
  summarise(beneficiaries = sum(beneficiaries)) %>% 
  pivot_wider(names_from = date, values_from = beneficiaries) %>% 
  unnest() %>% 
  ungroup() %>% 
  mutate(recurrences = rowSums(!is.na(select(., -implementing_partners, -activity, -state, -township, -location))),
         ben_max = pmax(`2021-01-01`, `2021-02-01`, `2021-03-01`, `2021-04-01`, `2021-05-01`, `2021-06-01`,
                        `2021-07-01`, `2021-08-01`, `2021-09-01`, `2021-10-01`, `2021-11-01`, `2021-12-01`, na.rm = TRUE)) %>%
  pivot_longer(cols = c(`2021-01-01`, `2021-02-01`, `2021-03-01`, `2021-04-01`, `2021-05-01`, `2021-06-01`,
                        `2021-07-01`, `2021-08-01`, `2021-09-01`, `2021-10-01`, `2021-11-01`, `2021-12-01`), 
               names_to = "date", values_to = "beneficiaries") %>% 
  mutate(distribution = ifelse(is.na(beneficiaries), "n", "y")) %>% 
  select(-beneficiaries) %>% 
  pivot_wider(names_from = date, values_from = distribution) %>% 
  mutate(gaps = paste0(`2021-01-01`, `2021-02-01`, `2021-03-01`, `2021-04-01`, `2021-05-01`, `2021-06-01`,
                        `2021-07-01`, `2021-08-01`, `2021-09-01`, `2021-10-01`, `2021-11-01`, `2021-12-01`)) %>% 
  mutate(gap_months = case_when(str_detect(gaps, "ynnnnnnnnnnny") ~ 11,
                                str_detect(gaps, "ynnnnnnnnnny") ~ 10,
                                str_detect(gaps, "ynnnnnnnnny") ~ 9,
                                str_detect(gaps, "ynnnnnnnny") ~ 8,
                                str_detect(gaps, "ynnnnnnny") ~ 7,
                                str_detect(gaps, "ynnnnnny") ~ 6,
                                str_detect(gaps, "ynnnnny") ~ 5,
                                str_detect(gaps, "ynnnny") ~ 4,
                                str_detect(gaps, "ynnny") ~ 3,
                                str_detect(gaps, "ynny") ~ 2,
                                str_detect(gaps, "yny") ~ 1,
                                TRUE ~ 0)) 

## commented out, but this was just to get the number of townships with gaps per state
# gap_months %>% 
#   filter(recurrences > 1) %>% 
#   group_by(state, township) %>% 
#   summarise(avg_gap = mean(gap_months), 
#             beneficiaries = sum(ben_max)) %>% 
#   arrange(desc(avg_gap)) %>%
#   filter(avg_gap > 0) %>% 
#   group_by(state) %>%
#   summarise(townships = n_distinct(township))

gap_months %>% 
  filter(recurrences > 1) %>% 
  group_by(gap_months) %>% 
  summarise(locations = n_distinct(location),
            townships = n_distinct(township),
            beneficiaries = sum(ben_max)) %>% 
  mutate(pc_of_ben = round(beneficiaries / sum(beneficiaries) * 100, digits = 2)) %>%
  kable(caption = "Number of beneficiaries and locations by duration of gaps in implementation", format.args = list(big.mark = ",")) %>% 
  kable_classic_2("striped", full_width = FALSE, position = "left")
  # pander(caption = "Number of beneficiaries and locations by duration of gaps in implementation")

# reminder to check the paragraph below when you rerun the report

```
 
 <br>
 
`r round(filter(gap_months, recurrences > 1 & gap_months > 0 ) %>% {sum(.$ben_max)} / filter(gap_months, recurrences > 1) %>% {sum(.$ben_max)} * 100)`% of beneficiaries experienced gaps or delays in monthly programming, with the most common delay being 3 months. The 8-month delay was the provision of monthly food baskets in Buthidaung, where distributions only occurred in February and November 2021. The 5-month delays were all from locations in Rakhine and Kachin. Overall, gaps in monthly programming were experienced in 39 townships, with the majority orginating from Kachin, Ayeyarwady and Rakhine.

There are `r filter(gap_months, recurrences == 1) %>% nrow()` entries coded as being implemented on a monthly basis that have not recurred -- that is, they have only been implemented once: we should check with partners if these are merely the first instances, or if there have been issues with access, security or funding or if they are errors in data entry .

<br>

### 4.4 Potential for post-distribution monitoring

The table below shows activities which have been implemented for 6 months or more, the number of locations they were implemented in and the number of unique beneficiaries reached by activities meeting these criteria. The possibility of joint monitoring -- or at least the joint review and analysis of monitoring data -- will be explored, in consultation with these partners. The rationale being that 6 months of implementation should be a long enough period of time to make impact monitoring feasible; additionally, joint monitoring will be further facilitated by the similarity of these activities, almost all of which are recurrent cash transfers or distributions of food baskets.

```{r table-monthly-activities-6-9-months, warning=FALSE}

gap_months %>%  
  filter(recurrences > 5) %>% 
  group_by(activity) %>% 
  summarise(partners = n_distinct(implementing_partners),
            locations = n(),
            beneficiaries = sum(ben_max)) %>% 
  arrange(desc(beneficiaries)) %>% 
  kable(caption = "Number of beneficiaries, by activity, who have received at least 6 months of recurrent food security support",
        format.args = list(big.mark = ",")) %>% 
  kable_classic_2()
  # pander(caption = "Number of beneficiaries, by activity, who have received at least 6 months of recurrent food security support")

```

<br>

These are the partners who have implemented monthly food baskets and monthly cash-based transfers for more than 6 months:

```{r}
gap_months %>%  
  filter(recurrences > 5) %>% 
  group_by(activity, implementing_partners) %>% 
  summarise(beneficiaries = sum(ben_max)) %>%  
  filter(activity == "Provide monthly food baskets" | activity == "Provide monthly cash-based transfers") %>% 
  pivot_wider(names_from = activity, values_from = beneficiaries) %>% 
  kable(caption = "Partners who have implemented cash transfers and food baskets for at least 6 months", 
        format.args = list(big.mark = ",")) %>% 
  kable_classic_2("striped")
```

<br><br>

## 5. Next steps

1.  Communicate to partners that Yangon is severely oversubscribed in comparison to the rest of the country, above all in the townships of Hlaingtharya, Shwepyithar, Dagon Myothit (Seikkan), Dala and North Okkalapa.

2.  Collect existing intervention packages from partners in order to begin the process of standardisation and to support the review of food baskets for their caloric and nutritional value. Perform additional analysis to understand if beneficiaries in close proximity to each other have received widely divergent package values. Additionally, speak with partners to understand why cash transfer values vary even within the same activity implemented by the same partner.

3.  Revisit areas which have only received smaller supplementary transfers -- a transfer of around USD 10 per household per month cannot be considered to have covered the food security needs for that area -- other partners may be necessary to cover the gap.

4.  Advocate for the expansion of partners' geographic footprints to reach the remaining 179 townships which have yet to benefit from any FSC activities. The effects of the current crisis in Myanmar have not been determined by an epicentre or a stormpath and there is no programmatic rationale for the response to be so uneven. This advocacy should be targetted at the ICCG, Cluster partners and at donors.

5.  Collect 5W data from other clusters so that multi-sector coverage may be reviewed. Clean and process conflict data so that it may be cross-referenced with partners' coverage. Share raw data with other Clusters to improve coordination.

6.  Work with partners to determine their current capacities to submit age and sex-disaggregated beneficiary data. Develop a workplan to ensure that they can meet reporting requirements.

7.  Solicit monitoring reports from partners and explore the possibility of joint monitoring.

8.  Revise the 5W template -- in consultation with partners -- in order to address the data collection issues identified.

<br><br>

## 6. Reference table -- townships

The reference table below may be sorted and filtered by any of the columns. 

```{r datatable-townships-reference}
# add in target
pin %>% 
  select(state, township, admin3_pcode, total_pop, PIN_2022 = pin_2022, IDPs = idps) %>% 
  mutate(total_pop = round(total_pop, digits = 0)) %>% 
  left_join(fsc %>%
              select(activity, partners = implementing_partners, beneficiaries = u_ben, beneficiary_frequencies = beneficiaries,
                     location, admin3_pcode) %>% 
              group_by(admin3_pcode) %>% 
              summarise(partners = n_distinct(partners),
                        beneficiaries = sum(beneficiaries),
                        beneficiary_frequencies = sum(beneficiary_frequencies),
                        locations = n_distinct(location)), by = "admin3_pcode") %>%
  replace_na(list(partners = 0, beneficiaries = 0, beneficiary_frequencies = 0, locations = 0)) %>% 
  relocate(admin3_pcode, .after = locations) %>% 
  arrange(desc(beneficiaries)) %>% 
  datatable(filter = "top", options = list(pageLength = 10, scrollX = TRUE,
                                           initComplete = htmlwidgets::JS(
          "function(settings, json) {",
          paste0("$(this.api().table().container()).css({'font-size': '", "8.5pt", "'});"),
          "}")
       ) 
     ) 
```

<br><br>

## 7. Interactive maps -- 2022 PIN and 2021 beneficiaries reached

<br>

```{r reference-map-ggplotly, fig.height=10}

# I think you need to coalesce the states and townships with pcode3_shape or start with pcode3_shape
tsp_map <- pcode3_shape %>% 
  left_join(ben %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries),
                        partners = n_distinct(implementing_partners),
                        activities = n_distinct(activity)), by = "admin3_pcode") %>% 
  left_join(pin %>% 
              select(admin3_pcode, total_pop, idps, pin_2022), by = "admin3_pcode") %>% 
  replace(is.na(.), 0) %>% 
  mutate(total_pop = round(total_pop)) %>% 
  st_as_sf() %>% 
  ggplot() + 
  geom_sf(size = 0.1,
          aes(fill = pin_2022,
              text = paste0(township, ",", "\n",
                            state, "\n",
                            "PIN 2022: ", pin_2022, "\n",
                            "total pop: ", total_pop, "\n",
                            "IDPs: ", idps, "\n",
                            "org count: ", partners, "\n",
                            "beneficiaries: ", beneficiaries))) +
  scale_fill_viridis_c(option = "mako", direction = -1) + 
  labs(fill = "PIN 2022",
       title = "Map of townships by 2022 PIN") +
  theme_void() + 
  theme(legend.title = element_text(size = 8),
        legend.text = element_text(size = 8),
        plot.title = element_text(size = 12)) 

ggplotly(tsp_map, tooltip = c("text")) %>%
  layout(showlegend = TRUE, legend = list(font = list(size = 6))) %>% 
  plotly::style(hoveron = "fill") %>% 
  layout(title = list(text = paste0("Map of townships by 2022 PIN",
                                    "<br>",
                                    "<sup>",
                                    "mouse over for details; click and drag to select and zoom","</sup>")))
```

<br>

```{r beneficiaries-map-ggplotly, fig.height=10}

# I think you need to coalesce the states and townships with pcode3_shape or start with pcode3_shape
tsp_map_ben <- pcode3_shape %>% 
  left_join(fsc %>% 
              filter(unique_beneficiaries == "Yes") %>% 
              group_by(admin3_pcode) %>% 
              summarise(beneficiaries = sum(beneficiaries),
                        partners = n_distinct(implementing_partners),
                        activities = n_distinct(activity)), by = "admin3_pcode") %>% 
  left_join(pin %>% 
              select(admin3_pcode, pin_2022), by = "admin3_pcode") %>% 
  st_as_sf() %>% 
  ggplot() + 
  geom_sf(size = 0.1,
          aes(fill = beneficiaries,
              text = paste0(township, ",", "\n",
                            state, "\n",
                            "beneficiaries: ", beneficiaries, "\n",
                            "org count: ", partners, "\n",
                            "act count: ", activities, "\n",
                            "PIN 2022: ", pin_2022))) +
  scale_fill_viridis_c(option = "mako", trans = "log10", direction = -1) + 
  labs(fill = "beneficiaries",
       title = "Map of townships by beneficiaries reached in 2021") +
  theme_void() + 
  theme(legend.title = element_text(size = 8),
        legend.text = element_text(size = 8),
        plot.title = element_text(size = 12)) 

ggplotly(tsp_map_ben, tooltip = c("text")) %>%
  layout(showlegend = TRUE, legend = list(font = list(size = 6))) %>% 
  plotly::style(hoveron = "fill") %>% 
  layout(title = list(text = paste0("Map of townships by beneficiaries reached in 2021",
                                    "<br>",
                                    "<sup>",
                                    "mouse over for details; click and drag to select and zoom","</sup>")))
```
